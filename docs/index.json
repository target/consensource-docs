[{"body":"In today\u0026rsquo;s ever changing digital environment, companies are continually challenged with keeping accurate records. This ongoing record and data maintenance challenge is true across many facets of business, including keeping accurate records of certifications and audits related to supply chains for products and their raw materials. Even when these records are being provided via a website or some other electronic mechanism, they generally are not provided with the customer and recipient of those records in mind, making the ability to keep up to date and accurate records difficult, if not impossible. Additionally, every system of record has a different way of providing access, which forces those looking for the information to have a different approach for each source.\nMeaning, the often antiquated and outdated way that certification records are provided to others creates an ever increasing challenge and risk to brands and retailers who not only desire and rely on accurate information, but also find this information critically important to their business. Ultimately, the increasing push for transparency from brands and retailers as well as an increasingly high expectation from consumers is why we believe a change in how this information is captured and shared needs to be made on a broad scale. ConsenSource aims to solve this problem.\n","excerpt":"In today\u0026rsquo;s ever changing digital environment, companies are continually challenged with …","ref":"https://target.github.io/consensource-docs/docs/business/context-problem-statement/","title":"Context and Problem Statement"},{"body":"The first step to working with ConsenSource is getting it up and running. The guides below have detailed instructions on running the ConsenSource network in various environments.\n","excerpt":"The first step to working with ConsenSource is getting it up and running. The guides below have …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/","title":"Getting Started"},{"body":" Requirements The following tools are required to run ConsenSource locally:\n Docker - brew install docker  If you wish to perform development work, the following additional tools are required:\n npm - brew install node Rust/Rustup  How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.   Clone the ConsenSource repo  Via HTTPS: git clone https://github.com/target/consensource-compose.git consensource Via SSH: git clone git@github.com:target/consensource-compose.git consensource  cd consensource Pull down Docker images from DockerHub  docker-compose pull(the images are quite large and will take some time to download)  Start the network  docker-compose up   Available Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"Requirements The following tools are required to run ConsenSource locally:\n Docker - brew install …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/mac/","title":"macOS"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/user-personas/retailer/","title":"Retailer"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/","title":"Running ConsenSource Locally"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/user-personas/","title":"User Personas"},{"body":"   ","excerpt":"   ","ref":"https://target.github.io/consensource-docs/docs/developer/architecture-overview/","title":"Architecture Overview"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/user-personas/factory/","title":"Factory"},{"body":" Private \u0026amp; Public Key Overview ConsenSource utilizes public-key cryptography. Public keys are stored on-chain and accessible to all nodes in the network, and a user\u0026rsquo;s private key is stored in an encrypted format off-chain.\nWhenever a user creates a transaction, the contents of the payload are serialized, signed with the user\u0026rsquo;s private key, and committed with the transaction. This signature can later be decrypted with the user\u0026rsquo;s public key to verify that the contents of the payload are unchanged, and to prove that a given user created a transaction.\nPrivate and Public keys in ConsenSource are generated with secp256k1 using the ECDSA algorithm using the sawtooth-signing library. When storing private keys in a database, the SJCL encyrption library is used.\nKey Management Browser Storage Browser storage is used as a temporary store for the public and private keys of a user.\nLocal Storage:\n Stores a User object containing the following fields  username, public_key, name, email, encrypted_private_key   Session Storage:\n Stores the decrypted private key  User Creation When filling out the Sign Up form, a User object is created along with a corresponding Agent in order to store the hashed password and encrypted private key. The Agent is stored on-chain, but the User is stored off-chain.\nThe User is fetched from the database when signing in to ConsenSource. The User object is then saved to local storage, and the decrypted private key is saved to session storage.\nTakeaway A User is an off-chain object that is used to store the hashed password and encrypted private key of a user.  The diagram below goes into more detail on the user creation process.\nUser creation workflow in ConsenSource   Additional Sawtooth Docs  Creating Private and Public Keys  ","excerpt":"Private \u0026amp; Public Key Overview ConsenSource utilizes public-key cryptography. Public keys are …","ref":"https://target.github.io/consensource-docs/docs/developer/ui/key-mgmt/","title":"Key Management"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/gcp/","title":"Running ConsenSource In GCP"},{"body":"ConsenSource aims to solve the issue with ongoing maintenance and record keeping of certifications and audits that are issued to suppliers and vendors of brands and retailers. Fundamentally shifting the onus of maintenance and upkeep from all of the disparate parties that receive and maintain this information today to a decentralized platform in the future means that producers and consumers of that information will more broadly benefit from the timely and accurate records those certifications are intended to represent.\nThe platform is also intended to create additional incentives related to awareness and marketability related to the other personas that are intended to interact and contribute data to the platform. The platform is intended to benefit and incentivize each persona uniquely and not create disincentives for any given persona ultimately for its adoption and future growth.\n","excerpt":"ConsenSource aims to solve the issue with ongoing maintenance and record keeping of certifications …","ref":"https://target.github.io/consensource-docs/docs/business/value-proposition/","title":"Value Proposition"},{"body":" How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.  TODO\nAvailable Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/windows/","title":"Windows"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/user-personas/cert-body/","title":"Certifying Body"},{"body":" What Is A Blockchain? A blockchain is a network in which a record of transactions are maintained across several computers that are linked in a peer-to-peer network. All nodes in this network reach consensus on what the state of the ledger should look like before adding to it. This enforces a level of trust and transparency regarding the authenticity and immutability of data within the ledger.\nBlockchains are a particular type of distributed ledger technology (DLT), and as such, we have elected to use the broader term, DLT, as we further develop ConsenSource.\n What Is A Permissioned Blockchain? Blockchains can be further subdivided into two categories - permissionless and permissioned.\nPermissionless systems, such as Bitcoin and Ethereum, allow anybody to join the network. This approach works great in an open environment such as peer-to-peer cash, but it has two main drawbacks - efficiency and control.\nIn a permsionless system it must be assumed that all actors on the network are potentially malicious. This requires a more costly consensus algorithm, such as Proof-of-Work, in order to verify that transactions are authentic. The second drawback is lack of control over which actors are allowed to join the network. For many enterprise use cases, such as ConsenSource, there is a need to limit the network to only relevant actors.\nPermissioned systems aim to solve these two problems of efficiency and control. ConsenSource uses Hyperledger Sawtooth, an enterprise DLT, to provide an additional layer of security and access control by allowing for on-chain governance.\nIn practice, this means that all members of the network must reach consensus around which new actors are allowed to join the network, the types of actions they can perform, and more. A permissioned DLT lets ConsenSource use a more efficient consensus algorithm (more info here - todo) because there is a base level of trust between participants in the network.\nTakeaway ConsenSource uses a permissioned DLT to provide both greater efficiency, and control, of the network.  Why Use DLT? Benefits  Enhanced Trust  In a centralized database solution, all parties must trust the owner of the database - in situations with potentially untrusted participants, this is often not practical. DLT enforces trust by enabling all parties to share an immutable and complete record of all transactions that occur in the network.  Distributed Responsibility  Rather than a single party bearing the burden of maintaing and running a centralized database, DLT allows multiple parties to collaboratively maintain a ledger of transactions.  Improved Efficiency  The process of manually reconciling multiple ledgers, between multiple parties, is time consuming, expensive, and error prone. By sharing a single digital ledger, all parties recieve more accurate data while performing less work.   Tradeoffs  Blockchain is an emerging technology  As such, the platforms and tools in the blockchain ecosystem are changing rapidly, and many developers have little experience with the technology. The Hyperledger Sawtooth platform supports a wide variety of programming languages for smart contract development, making it easier for new developers to utilize their existing skills.  Reaching consensus is time consuming  The network much reach consensus regarding the validity of all transactions in the network. This takes time, and is slower than a traditional database. ConsenSource utilizes an efficient consensus algorithm to reduce network latency.  Multiple parties need to run validator node  The premise of blockchain technology is built around multiple parties running nodes that validate transactions, rather than a single entity managing and maintaining the network. This enforces transparency and trust around the validity of all transactions. ConsenSource has documentation on running a node in multiple environments.   Why Sawtooth?  ","excerpt":"What Is A Blockchain? A blockchain is a network in which a record of transactions are maintained …","ref":"https://target.github.io/consensource-docs/docs/business/dlt-overview/","title":"Distributed Ledger Technology (DLT) Overview"},{"body":" How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.  TODO\nAvailable Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/linux/","title":"Linux"},{"body":" Below is a list of common terminology / acronyms used in ConsenSource.\nTerminology Acronyms - TP: Transaction Processor - TF: Transaction Family - SDS: State Delta Subscriber - Protos/Protobufs: Protocol Buffers ","excerpt":" Below is a list of common terminology / acronyms used in ConsenSource.\nTerminology Acronyms - TP: …","ref":"https://target.github.io/consensource-docs/docs/developer/terminology/","title":"Terminology"},{"body":" Transactions \u0026amp; Batches In Sawtooth In Hyperledger Sawtooth, the state of the blockchain can only be modified through transactions. As a user interacts with the application, transactions are constructed. The contents of a transaction are signed with the user\u0026rsquo;s private key in an irreversible, one-way hashing function (secp256k1 ECDSA).\nThe resulting signature can be decoded with the user\u0026rsquo;s public key. This decoding process is used to verify that a transaction was not modified after being signed by the user.\nTransactions are then wrapped into a batch. Batches are the atomic unit of change in Sawtooth - either all of the transactions in a batch are committed together, or the entire batch is rejected. A batch is sent from the UI to the API, which is then forwarded to a Sawtooth validator node that verifies the signature and payload of each transaction before updating the blockchain state.\nTakeaway The state of the ConsenSource blockchain is updated by transactions wrapped in a batch that get sent to a validator node. The UI constructs and signs transactions on behalf of a user.  The diagram below provides an overview of the sturcture of transactions and batches in Sawtooth.\nTransaction and Batch relationship   Building and Submitting Transactions Transaction Family The ConsenSource Transaction Family is designed to model the existing business processes that occur when a factory receives a new certification. View the full specification at the link below.\nTransaction Processor \u0026amp; Family Documentation\nSigning Transactions Additional Sawtooth Docs  Transactions and Batches Addressing \u0026amp; Namespace Design Building and Submitting Transactions  ","excerpt":"Transactions \u0026amp; Batches In Sawtooth In Hyperledger Sawtooth, the state of the blockchain can only …","ref":"https://target.github.io/consensource-docs/docs/developer/ui/txns-batches/","title":"Transaction \u0026 Batch Building"},{"body":" View the ConsenSource API on Github  ","excerpt":" View the ConsenSource API on Github  ","ref":"https://target.github.io/consensource-docs/docs/developer/api/","title":"REST API"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/block-watcher/","title":"Block Watcher"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/user-personas/standards-body/","title":"Standards Body"},{"body":" View the ConsenSource CLI on Github  ","excerpt":" View the ConsenSource CLI on Github  ","ref":"https://target.github.io/consensource-docs/docs/developer/cli/","title":"Command Line Interface"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/ui/protobuf/","title":"Protocol Buffers"},{"body":" View the ConsenSource SDS on Github  The goal of State Delta Export is to provide a mechanism for exporting on-chain state values from a validator to an external data store. This allows applications to efficiently query their state values. The state delta export implements an event subscription client that subscribes to block commit events and Sawtooth state delta at specific addresses (in this case we will subscribe to all state delta events at the Certificate Registry namespace). Sawtooth sends these events whenever the validator’s state is updated. The events contain the raw state data at the updated addresses. The event subscription client processes the event data and uses it to update the reporting database, an off-chain copy of blockchain state. The REST API can query this database when a client needs to get information from the blockchain.\nThis off-chain state access comes at the expense of relying on a single validator for state updates, this puts the application at risk of having stale data or forked state if the validator supplying the state updates comes out of consensus or is disconnected from the network. Below are guidelines on how to structure the reporting DB so fork resolution is easy.\nReporting Database Structure The reporting DB has three types of tables: sawtooth-core tables (Blocks), domain-specific state tables (Agents, Organizations, Authorizations, Certificates, CertificateData), and application tables (tables supporting off-chain application components, such as Auth, in the schema above). The reporting DB should follow the Type 2 of Slowly Changing Dimensions data management pattern, so that fork resolution is easy.\nFor use in a State Delta Export, a state table includes additional columns of start_block_num and end_block_num. The ​start_block_num​ and ​end_block_num​ columns specify the block range in which that state value is set or exists. Values that are valid as of the current block have ​end_block_num​ set to MAX_UINT_64.\nBecause there might be state objects in the database that refer to the same object in state at different block heights (with different block numbers), the primary key for each object cannot be the same as the object’s natural key in blockchain state. Instead, use a sequence ID column or another unique ID scheme as the primary key. For better query performance, we recommend creating indexes on the natural key of the entry and the end_block_num.\nFork resolution The following pseudocode demonstrates the fork resolution process:\nresolve_fork(existing_block): for table in domain_tables: delete from table where start_block_num \u0026gt;= existing_block.block_num update table set end_block_num = MAX_UINT_64 \\ where end_block_num \u0026gt;= existing_block.block_num delete from block where block_num \u0026gt;= existing_block.block_num  ","excerpt":"View the ConsenSource SDS on Github  The goal of State Delta Export is to provide a mechanism for …","ref":"https://target.github.io/consensource-docs/docs/developer/sds/","title":"State Delta Subscriber"},{"body":" View the ConsenSource Transaction Processor on Github  ConsenSource is a certificate registry, as data pertaining to the process of factory certification is captured in the ledger state. This Certificate Registry (henceforth referred to as CR) Transaction family displays the interactions currently implemented for any participant that affects state data. Furthermore, this lays out the logic behind all interactions to verify the data submitted to the ledger.\nRelevant Links  Assembling the Future of Smart Contracts with Sawtooth Sabre  Addressing CR data is stored in state using addresses generated from the CR Transaction family name and the object type being stored. In particular, a CR address consists of 4 parts creating a 70 hex character string.\n The first 6 characters of the SHA-256 hash of the UTF-8 encoding of the string \u0026ldquo;certificate_registry\u0026rdquo; (439a56).\n The next 2 characters reserve a namespace and we will start with the namespace 00.\n The next 2 characters are determined by the object type.\n 00 will signify an agent object. 01 will signify a certificate object. 02 will signify an organization object. 03 will signify a standard object. 04 will signify a request object.  The final 60 characters is a truncated value of the SHA-256 hash of the UTF-8 encoding of:\n The public key string of the agent creating the object (first 60 chars of the hash) for an agent object. The certificate id for a certificate object. The organization id for an organization object. The standard id for a standard object. The request id for a request object.   For example, the CR address for the creation of an agent object would look like the following: 439a560000DFB4D55EE01720E8F098CA4F5063C67BDEA82732113C9D41B3F345B1EAFA\nState Agent State A CR Agent state entry is required to consist of the following protobuf message:\nagent.proto\nmessage Agent { // Public key associated with the agent.  string public_key = 1; // A human-readable name identifying the agent.  string name = 2; // A human-readable organization ID identifying the associated org.  string organization_id = 3; // Approximately when the agent was registered.  // Format: UTC timestamp  uint64 timestamp = 4;}message AgentContainer { repeated Agent entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the agent container defined in the proto file above.\nOrganization State A CR Organization state entry is required to consist of the following protobuf message:\norganization.proto\nmessage Organization { enum Type { UNSET_TYPE = 0; CERTIFYING_BODY = 1; STANDARDS_BODY = 2; FACTORY = 3; } message Authorization { enum Role { UNSET_ROLE = 0; ADMIN = 1; TRANSACTOR = 2; } // Public key of the authorized agent. string public_key = 1; // Agent's role within the organization. Role role = 2; } message Contact { // Name of the person. string name = 1; // Contact's phone number. string phone_number = 2; // ISO 639‑1 language code of the contact. string language_code = 3; } // UUID of the organization. string id = 1; // Name of the organization. string name = 2; // List of authorized agents and their roles within the organization. repeated Authorization authorizations = 3; // List contacts within the organization. repeated Contact contacts = 4; // What type of organization this data represents. Type organization_type = 5; // Only one of these fields will be filled based on the organization type. CertifyingBody certifying_body_details = 6; StandardsBody standards_body_details = 7; Factory factory_details = 8; } message CertifyingBody { message Accreditation { // Standard for which the accreditation has been issued. string standard_id = 1; // Standard version for which the accreditation has been issued. string standard_version = 2; // Standards body that issued the accreditation. string accreditor_id = 3; // Time range that the accreditation is valid (UTC Timestamps) uint64 valid_from = 4; uint64 valid_to = 5; } // List of accreditations that the certifying body holds. repeated Accreditation accreditations = 1; } message StandardsBody { // This is message could be used to capture information that is only // pertinent to a StandardsBody } message Factory { message Address { // Street address, Line 1 string street_line_1 = 1; // Street address, Line 2 (optional) string street_line_2 = 2; // City string city = 3; // State or province, (optional) string state_province = 4; // Country string country = 5; // Postal Code, (optional) string postal_code = 6; } // Location of the factory Address address = 1; } message OrganizationContainer { repeated Organization entries = 1; }  In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the organization container defined in the proto file above.\nCertificate State A CR Certificate state entry is required to consist of the following protobuf message:\ncertificate.proto\nmessage Certificate { message CertificateData { // Name of data field associated with certificate data.  string field = 1; // Data stored within the data field.  string data = 2; } // This certificate\u0026#39;s ID.  string id = 1; // Certifying body that issued the certificate.  string certifying_body_id = 2; // Factory the certificate was issued to.  string factory_id = 3; // Standard that this certificate is for.  string standard_id = 4; // Standard version that the certificate is for.  string standard_version = 5; // Additional certificate data.  repeated CertificateData certificate_data = 6; // Time certificate was issued.  // Format: UTC timestamp  uint64 valid_from = 7; // Approximately when the certificate will become invalid.  // Format: UTC timestamp  uint64 valid_to = 8;}message CertificateContainer { repeated Certificate entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the certificate container defined in the proto file above.\nRequest State A CR Request state entry is required to consist of the following protobuf message:\nrequest.proto\nmessage Request { enum Status { UNSET_STATUS = 0; OPEN = 1; IN_PROGRESS = 2; CLOSED = 3; CERTIFIED = 4; } // UUID of this request.  string id = 1; // Status of the request.  Status status = 2; // The standard the factory is requesting certification against.  string standard_id = 3; // UUID of the factory that created this request.  string factory_id = 4; // Time request was made  // Format: UTC timestamp  uint64 request_date = 5;}message RequestContainer { repeated Request entries = 1;} Standard State A CR Standard state entry is required to consist of the following protobuf message:\nrequest.proto\nmessage Standard { message StandardVersion { // Standard version  string version = 1; // Short description of the standard.  string description = 2; // Link to the standard\u0026#39;s documentation.  string link = 3; // Date the standard is officially issued.  uint64 approval_date = 4; } // Sha256 of the standard name  string id = 1; // Id of the organization that created this Standard.  string organization_id = 2; // Name of the standard.  string name = 3; // List of different versions of the standard.  repeated StandardVersion versions = 4;}message StandardContainer { repeated Standard entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the request container defined in the proto file above.\nTransaction Payload CR transaction request payloads are defined by the following protobuf structure:\npayload.proto\nmessage CertificateRegistryPayload{ enum Action { UNSET_ACTION = 0; CREATE_AGENT = 1; CREATE_ORGANIZATION = 2; UPDATE_ORGANIZATION = 3; AUTHORIZE_AGENT = 4; ISSUE_CERTIFICATE = 5; CREATE_STANDARD = 6; UPDATE_STANDARD = 7; OPEN_REQUEST_ACTION = 8; CHANGE_REQUEST_STATUS_ACTION = 9; ACCREDIT_CERTIFYING_BODY_ACTION = 10; } // Whether the payload contains a create agent, create organization,  // create certificate, or authorize agent.  Action action = 1; // The transaction handler will read from just one of these fields  // according to the action.  CreateAgentAction create_agent = 2; CreateOrganizationAction create_organization = 3; UpdateOrganizationAction update_organization = 4; AuthorizeAgentAction authorize_agent = 5; IssueCertificateAction issue_certificate = 6; CreateStandardAction create_standard = 7 ; UpdateStandardAction update_standard = 8; OpenRequestAction open_request_action = 9; ChangeRequestStatusAction change_request_status_action = 10; AccreditCertifyingBodyAction accredit_certifying_body_action = 11;} Based on the selected type, the data field will contain the appropriate transaction data (these messages would be defined within the CertificateRegistryPayload):\nCreateAgentAction transaction The CreateAgentAction transaction creates an agent object that is able to sign transactions and perform actions on the behalf of their associated organization. This agent object will be initialized with no associated organization ID.\nCreateAgentAction protobuf\nmessage CreateAgentAction { // A name identifying the agent.  string name = 1; // Approximately when the agent was registered.  // Format: UTC timestamp  uint64 timestamp = 2;} This transaction is considered invalid if one of the following occurs:\n Name is not provided Signing public key already associated with an agent  CreateOrganizationAction transaction The CreateOrganizationAction transaction creates an organization object. An organization may either be an STANDARDS_BODY, CERTIFYING_BODY or a FACTORY depending on the actions the organization will perform, such as creating standards, issuing or requesting certificates. These actions are performed by authorized agents associated with the organization. The organization object created will be initialized with the agent that signed the transaction as an ADMIN within the organization\u0026rsquo;s authorizations list.\nCreateOrganizationAction protobuf\nmessage CreateOrganizationAction { // UUID of the organization.  string id = 1; // Type of the organization.  Organization.Type organization_type = 2; // Name of the organization.  string name = 3; // Initial contact info for the organization.  repeated Organization.Contact contacts = 4; // Address of the organization (if the organization is a Factory).  Factory.Address address = 5;} This transaction will be considered invalid if one of the following occurs:\n Organization ID, name, and/or organization type are not provided Organization ID already exists Signing public key is not associated with a valid Agent object Agent submitting the transaction already has an associated organization Address is provided if the type is Standards Body or Certifying Body Address is not provided if the type is Factory  UpdateOrganizationAction transaction The UpdateOrganizationAction transaction modifies the value of an Organization in state. Both the address (for factories) and the contact information may be updated. The values provided will be applied exactly as submitted with the transaction. If one or the other should stay the same, the original values should be supplied.\nUpdateOrganizationAction protobuf\nmessage UpdateOrganizationAction { // Updated contact info.  repeated Organization.Contact contacts = 1; // Updated address (if Factory).  Factory.Address address = 2;} This transaction is considered invalid if one of the following occurs:\n The signer of the transaction is not listed as an admin of their organization Provided contacts or address objects are not fully filled out Address is provided if the organization is not a factory  AuthorizeAgentAction transaction The AuthorizeAgentAction transaction creates an entry within an organization\u0026rsquo;s authorizations list for the specified public key with the specified role. This action may only be performed by an agent authorized as an ADMIN by their associated organization.\nAuthorizeAgentAction protobuf\nmessage AuthorizeAgentAction { // Public key associated with the agent.  string public_key = 1; // Role to update the specified agent entry.  // Roles grant permissions for an agent to act on behalf of the  // organization.  // Whether the agent is an ADMIN or ISSUER.  Organization.Authorization.Role role = 2;} This transaction is considered invalid if one of the following occurs:\n Public key is not provided Role is not provided Signing public key is not associated an Agent Public key provided is not associated an Agent Agent submitting the transaction is not authorized as an ADMIN within their associated organization Public key provided specifies an Agent already associated with an organization Invalid authorization role is provided  IssueCertificateAction transaction The IssueCertificateAction transaction creates a certificate object that contains information pertaining to the specified factory and their adherence to certain policies. A Certificate object is created by an agent associated with a certifying body.\nIssueCertificateAction protobuf\nmessage IssueCertificateAction { enum Source { UNSET_SOURCE = 0; FROM_REQUEST = 1; INDEPENDENT= 2; } // UUID of the certificate.  string id = 1; // ID of the factory that the certificate is being issued to.  string factory_id = 2; // The source that triggered the IssueCertificate Trasaction.  // If set to FROM_REQUEST, it means the IssueCertificateAction is associated  // to a request made by a factory. The field request_id must be set.  // If set to INDEPENDENT, it means the IssueCertificateAction is not associated  // with a request made by a factory. The field factory_id and standard_id must be set.  Source source = 3; // ID of the request (if source is FROM_REQUEST)  string request_id = 4; // Standard that this certificate is for.  string standard_id = 5; // Additional certificate data.  repeated Certificate.CertificateData certificate_data = 6; // Time certificate was issued.  // Format: UTC timestamp  uint64 valid_from = 7; // Approximately when the certificate will become invalid.  // Format: UTC timestamp  uint64 valid_to = 8;} This transaction is considered invalid if one of the following occurs:\n ID, factory ID, standard name, valid from timestamp and/or valid to timestamp are not provided Certificate ID is already associated with a Certificate object Factory ID does not reference a valid factory Signing public key is not associated with an agent Agent submitting the transaction is not associated with a certifying body Certifying Body associated with the issuing agent is not accredited to issue the standard Agent submitting the transaction is not an authorized TRANSACTOR within their associated organization Standard name is not associated with an existing standard Invalid dates are provided, pertaining to current date as well as format  CreateStandardAction transaction The CreateStandardAction transaction creates a new certification standard in state. It will also create a StandardVersion sub-object, which contains details specific to the version of the standard which was supplied. A CreateStandardAction transaction is submitted by an agent associated with a standards body.\nCreateStandardAction protobuf\nmessage CreateStandardAction { // Sha256 of the standard name  string standard_id = 1; // Name of the standard.  string name = 2; // Current version of the standard.  string version = 3; // Short description of the standard.  string description = 4; // Link to the standard\u0026#39;s documentation.  string link = 5; // Date the standard is officially issued.  uint64 approval_date = 6;} This transaction is considered invalid if one of the following occurs:\n The standard_id, name, version, description, link, or approval date are not provided The standard_id is already associated with an existing standard The signer is not associated with a standards body The signer is not authorized as a transactor within their organization  UpdateStandardAction transaction The UpdateStandardAction transaction creates a new standard version in state, under the associated standard object. An UpdateStandardAction transaction is submitted by an agent associated with a standards body.\nUpdateStandardAction protobuf\nmessage UpdateStandardAction { // Standard that is being updated.  string standard_id = 1; // New version of the standard.  string version = 2; // Short description of the standard.  string description = 3; // Link to the standard\u0026#39;s documentation.  string link = 4; // Date the standard is officially issued.  uint64 approval_date = 5;} This transaction is considered invalid if one of the following occurs:\n The standard_id, version, description, link, or approval date are not provided The standard_id is not associated with an existing standard The version is already associated with an existing standard version The signer is not associated with a standards body The signer is not authorized as a transactor within their organization The standard is not associated with the signer\u0026rsquo;s organization  AccreditCertifyingBodyAction transaction The AccreditCertifyingBodyAction transaction adds an accreditation to a certifying body. An UpdateStandardAction transaction is submitted by an agent associated with a standards body.\nAccreditCertifyingBodyAction protobuf\nmessage AccreditCertifyingBodyAction { // UUID of the certifying body that is being accredited.  string certifying_body_id = 1; // Standard that the certifying body is being accredited for.  string standard_id = 2; // Time the accreditation was issued.  // Format: UTC timestamp  uint64 valid_from = 3; // When the accreditation will become invalid.  // Format: UTC timestamp  uint64 valid_to = 4;} This transaction is considered invalid if one of the following occurs:\n The signer is not associated with a standards body The signer is not authorized as a transactor within their organization The certifying body ID is not associated with a certifying body The name is not associated with an existing standard Invalid dates are provided, pertaining to current date as well as format  OpenRequestAction transaction The OpenRequestAction transaction opens a request for certification for a factory. This transaction is submitted by an agent associated with a factory and authorized as a TRANSACTOR for their associated factory.\nOpenRequestAction protobuf\nmessage OpenRequestAction { // UUID of the request  string request_id = 1; // Certification standard of which the factory is requesting from an certification body  Request.Certification_Standard certification_standard = 2; // Name of the factory that is opening the request  string factory_name = 3; // Time request was made  // Format: UTC timestamp  uint64 request_date = 4;} This transaction is considered invalid if one of the following occurs:\n The signer is not associated with a factory The signer is not authorized as a transactor within their organization The id is not unique The standards name is not associated with a valid standard If any of these fields are empty  ChangeRequestStatusAction transaction The ChangeRequestStatusAction transaction is performed when a factory\u0026rsquo;s certification request status is changed, such as to CLOSED, IN_PROGRESS, or CERTIFIED. This transaction results from either a factory changing the status to CLOSED or IN_PROGRESS, which would be submitted by an agent associated with the factory and authorized as a TRANSACTOR.\nChangeRequestStatusAction protobuf\nmessage ChangeRequestStatusAction { // Request for which the status is being changed.  string request_id = 1; // New status of the request.  Request.Status status = 2;} This transaction is considered invalid if one of the following occurs:\n The signer is not associated with a factory The signer is not authorized as a transactor within their organization A request with the provided id does not exist The status is not a valid status enum: IN_PROGRESS or CLOSED The status is already CLOSED or CERTIFIED  Transaction Header Family  family_name: \u0026ldquo;certificate_registry\u0026rdquo; family_version: \u0026ldquo;0.1\u0026rdquo;  Inputs and Outputs The inputs and outputs for Certification Registry transactions will differ depending on the transaction type. Inputs are the address(es) of all the state objects required to validate a transaction. Outputs are the address(es) of all the state objects modified by the transaction.\nCreateAgentAction Transaction Inputs:\n Address of the Agent to be created  Outputs:\n Address of the Agent created  CreateOrganizationAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization to be created\n  Outputs:\n Address of the Agent that submitted the transaction\n Address of the Organization created\n  AuthorizeAgent Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization with the authorization list being modified\n Address of the Agent to be added to the Organization\u0026rsquo;s authorization list\n  Outputs:\n Address of the Organization with a modified authorization list\n Address of the Agent added to the authorization list\n  IssueCertificateAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization the certificate is being submitted on behalf of\n Address of the Certificate to be created\n Address of the Standard the certificate is being created against\n  Outputs:\n Address of the Certificate created  CreateStandardAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  Outputs:\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  UpdateStandardAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  Outputs:\n Address of the Standard that is being created  AccreditCertifyingBodyAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being accredited for\n Address of the Organization that the transaction is being submitted on behalf of\n Address of the Organization that is being accredited\n  Outputs:\n Address of the Organization that is being accredited  OpenRequestAction Transaction Inputs:\n Address of the Request to be created\n Address of the Organization the Request is being made for\n Address of the Standard the Request is being made for\n  Outputs:\n Address of the Request to be created  ChangeRequestStatusAction Transaction Inputs:\n Address of the Request to be updated\n Address of the Organization the Request is being made for\n  Outputs:\n Address of the Request to be updated  Execution The result of a Certificate Registry transaction will differ depending on the type of transaction being executed.\nA successful CreateAgentAction transaction will result in a new Agent object created in state.\nA successful CreateOrganizationAction transaction will result in a new Organization object created in state. This Organization object will be initialized with a single authorization entry corresponding to the Agent that submitted the successful CreateOrganizationAction transaction with a role of ADMIN.\nA successful UpdateOrganizationAction transaction will result in an updated Organization object in state.\nA successful AuthorizeAgentAction transaction will result in a new entry to the specified Organization\u0026rsquo;s authorizations list. The Agent being added to the Authorizations list will also be updated with an associated Organization ID.\nA successful IssueCertificateAction transaction will result in a new Certificate object created in state.\nA successful CreateStandardAction transaction will result in a new Standard object in state, with one StandardVersion sub-object. The Standard will be added to the Standards Body\u0026rsquo;s standards list.\nA successful CreateStandardAction transaction will result in a new Standard object in state, with a new StandardVersion sub-object.\nA successful AccreditCertifyingBodyAction will result in a new Accreditation being added to an Organization object.\nA successful OpenRequestAction transaction will result in a new Request object in state.\nA successful ChangeRequestStatusAction transaction will result in an updated Request object in state with the status of provided. This Request will be submitted on behalf of a Factory.\n.. Licensed under Creative Commons Attribution 4.0 International License .. https://creativecommons.org/licenses/by/4.0/\n","excerpt":"View the ConsenSource Transaction Processor on Github  ConsenSource is a certificate registry, as …","ref":"https://target.github.io/consensource-docs/docs/developer/txn-processor/","title":"Transaction Processor \u0026 Family"},{"body":" View the ConsenSource UI on Github  Overview The ConsenSource UI allows users to accomplist two primary tasks:\n Submit transactions to the ConsenSource network that update the state of the blockchain Discover and monitor certification data, and organizations involved in the certification process  In order to submit transactions to the network, users are represented on the blockchain as an agent. Agents can act on behalf of an organization.\nPasswords and private keys are not stored on the blockchain - only the agent assosciated to a user is stored on-chain.\nAgents are created for a user during the sign up process. The admin of an organization can add or remove an agent at any point. All transactions that are submitted to ConsenSource must have an assosciated agent and organization.\nAn organization is representative of one of four distinct persona types:\n Retailers/Brands Factories Certifying Bodies Standards Bodies  Each of the personas has a distinct role in the certification lifecycle, and can only perform a specific set of actions that will update the state of the blockchain. For example, an agent that is a member of a factory organization cannot approve or deny certifications.\nThe organization that a user belongs to determines the set of components that they are able to interact with in the UI. For example, a Retailer/Brand is able to favorite a list of factories that they do business with, but a factory cannot favorite other factories.\nRead the guides below to learn more about the ConsenSource UI.\nConsenSource UI Guides ","excerpt":"View the ConsenSource UI on Github  Overview The ConsenSource UI allows users to accomplist two …","ref":"https://target.github.io/consensource-docs/docs/developer/ui/","title":"User Interface"},{"body":" This is a placeholder page that shows you how to use this template site.\n If your project has an API, configuration, or other reference - anything that users need to look up that’s at an even lower level than a single task - put (or link to it) here. You can serve and link to generated reference docs created using Doxygen, Javadoc, or other doc generation tools by putting them in your static/ directory. Find out more in Adding static content.\n","excerpt":"This is a placeholder page that shows you how to use this template site.\n If your project has an …","ref":"https://target.github.io/consensource-docs/docs/developer/troubleshooting/","title":"Troubleshooting"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/business/","title":"Business Documentation"},{"body":" Welcome to the ConsenSource Developer site!\nConsenSource is an application designed to bring transparency and trust to the sourcing industry - making it easier to find and verify the certifications and audit histories of a factory.\nThis section is intended to help software developers better understand how ConsenSource works, and how they can contribute to the project.\nIf you are interested in learning more about the business value of ConsenSource, you can read the Business Documentation.\nConsenSource Guides ","excerpt":"Welcome to the ConsenSource Developer site!\nConsenSource is an application designed to bring …","ref":"https://target.github.io/consensource-docs/docs/developer/","title":"Developer Documentation"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/index.json","title":""},{"body":"  About ConsenSource \nThe ConsenSource application empowers brands and retailers, factories, certifying bodies and standards bodies to increase transparency and efficiency around the certification process.\nFor many brands and retailers, a commom pain point in the sourcing process is the discovery and verification of the certification claims for a given factory. If a brand or retailer wishes to only do business with factories that have a given certification, where can they find a filtered list of only the factories that are certified? Furthermore, how can they trust that the certification is valid?\nIn practice, each brand and retailer ends up independently verifying these claims with the ceritfying body that performed the original audit. This process is time-consuming, expensive, and error prone.\n    How ConsenSource Can Help \nConsenSource solves this problem of trust and authenticity within the certification process using Distributed Ledger Technology (DLT). The application serves as a common platform to verify and display the certifications and audit data between brands and retailers, factories, certifying bodies, and standards bodies.\nDLT allows all partners to share ownership of this data. Each partner is tasked with the duty of owning their data and keeping this information up to date, shifting the onus of data accuracy to the relevant party. Each participant in the network plays a unique role.\n Standards bodies create standards and accredit certifying bodies.\n Certifying bodies are then able to audit and certify factories against the standards they are accredited for.\n Factories are able to request these certifications and in-person audits, so that certifying bodies are able to issue certificates based on in-person, off-chain audit results.\n Brands and Retailers are able to view and trust the resulting data from these interactions as well as general contact and location information on each of these entities.\n        Trusted The data that is input to ConsenSource is immutable, and distributed amongst all parties, creating verifiable trust that all inputs are authentic\n   Transparent Certification records and audit history are broadcasted and agreed upon by all members of ConsenSource\n   Permissioned The ConsenSource governing body controls permissioning of all actors in the network, limiting access to only approved and relevant organizations\n     Who Should Use ConsenSource? \n  Brands and Retailers     Reduction of overhead associated with tracking and maintaining vendor certification status and factory profile details   Avoidance of negative brand reputation impact by helping achieve and measure towards sustainability goals   Additional visibility to new vendors with applicable certifications and history      Factories     Easy to request certifications resulting in reduction of time locating validated certifying bodies and auditors   Potential for open competition drives audit costs down, or keeps audit costs in check      Certifying Bodies     Potential for increased business due to visibility to any factory interested in certification   Provides a low cost platform for sharing certification status      Standards Bodies     Ability to promote their standards to a wide range of industries, factories, and those requiring standards to further their mission         ","excerpt":"About ConsenSource \nThe ConsenSource application empowers brands and retailers, factories, …","ref":"https://target.github.io/consensource-docs/about/","title":"About ConsenSource"},{"body":"  #td-cover-block-0 { background-image: url(/consensource-docs/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_960x540_fill_catmullrom_top_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/consensource-docs/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_1920x1080_fill_catmullrom_top_2.png); } }  ConsenSource Read the docs   View the code   Certification transparency and authenticity to empower responsible sourcing\n          What is ConsenSource? ConsenSource is an application designed to bring transparency and trust to the sourcing industry - making it easier to find and verify the certifications and audit histories of a factory.     How It Works Sorry, your browser doesn't support embedded videos.       ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://target.github.io/consensource-docs/","title":"ConsenSource"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/","title":"Documentation"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/search/","title":"Search Results"}]