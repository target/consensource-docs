[{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/architecture-overview/","title":"Architecture Overview"},{"body":" GitHub Link https://github.com/target/consensource/tree/master/cli  ","excerpt":" GitHub Link https://github.com/target/consensource/tree/master/cli  ","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/cli/cli/","title":"Command Line Interface"},{"body":" Requirements The following tools are required to run ConsenSource locally:\n Docker - brew install docker  If you wish to perform development work, the following additional tools are required:\n npm - brew install node Rust/Rustup  How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.   Clone the ConsenSource repo  Via HTTPS: git clone https://github.com/target/consensource.git Via SSH: git clone git@github.com:target/consensource.git  cd consensource Pull down Docker images from DockerHub  docker-compose pull(the images are quite long and will take some time to download)  Start the network  docker-compose up   Available Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"Requirements The following tools are required to run ConsenSource locally:\n Docker - brew install …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/mac/","title":"macOS"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/client/retailer/","title":"Retailer View"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/","title":"Running ConsenSource Locally"},{"body":" GitHub Link https://github.com/target/consensource/tree/master/rest_api  ","excerpt":" GitHub Link https://github.com/target/consensource/tree/master/rest_api  ","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/api/rest-api/","title":"REST API"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/client/factory/","title":"Factory View"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/","title":"Getting Started"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/gcp/gcp/","title":"Running ConsenSource In GCP"},{"body":" How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.  TODO\nAvailable Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/windows/","title":"Windows"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/client/certifying-body/","title":"Certifying View"},{"body":" How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To run the app locally, we use docker-compose to orchestrate the container network.  TODO\nAvailable Services The following services should be available on your local machine at this point:\n ConsenSource Client: http://localhost:8080/ ConsenSource REST API: http://localhost:9009/ Sawtooth REST API: http://localhost:8008/ PostgreSQL Adminer: http://localhost:8081/  You can run the following cURL command to see the contents of the genesis block that was created on startup:\ncurl -X GET http://localhost:8008/blocks  Log In To A Container To log in to a running container for any of the services, you can run:\ndocker exec -it \u0026lt;container_name\u0026gt; /bin/bash  For example, to log in to the CLI, you can run:\ndocker exec -it consensource-cli /bin/bash  ","excerpt":"How To Run ConsenSource The ConsenSource application is comprised of a number of Docker images. To …","ref":"https://target.github.io/consensource-docs/docs/developer/getting-started/local/linux/","title":"Linux"},{"body":" Before You Begin A working knowledge of the following tools will be helpful when running and developing ConsenSource:\n Hyperledger Sawtooth Protocol Buffers (Protobufs) Docker Rust/Rustup  Running Local Images While developing, in order to run your updated code you will need to build and run local docker images rather than the images that have been pulled down from DockerHub.\nReplace A Remote Image With A Local Image To replace a Docker image pulled from a remote source with a local build, you can run this command:\ndocker-compose -d --build \u0026lt;service_name\u0026gt;  For example, to replace the CLI image, you can run:\ndocker-compose -d --build cli  Replace A Local Image With A Remote Image To pull an image from DockerHub back down and replace a local image, you can run:\ndocker-compose pull \u0026lt;service_name\u0026gt;  For example, to replace a local CLI image with one from DockerHub, you can run:\ndocker-compose pull cli  Troubleshooting See the ConsenSource troubleshooting guide\nGuides ","excerpt":"Before You Begin A working knowledge of the following tools will be helpful when running and …","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/","title":"Application Developer's Guide"},{"body":" The ConsenSource UI is comprised of a number of Mithril applications under the same router. The default application that is served from the index.html page is for retailers. To access the other apps, specify the relative .html file in /public such as localhost:8080/index_auditor.html.\nThe documentation below will provide a higher-level overview of the UI/UX interactions that can be performed through the client. Developer who wish to run or contribute to the client application should view project README for more information.\nRelevant Sawtooth Docs  Building and submitting transactions and batches  Guides ","excerpt":"The ConsenSource UI is comprised of a number of Mithril applications under the same router. The …","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/client/","title":"Client"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/client/standards-body/","title":"Standards Body View"},{"body":" GitHub Link https://github.com/target/consensource/tree/master/state_delta_subscriber  The goal of State Delta Export is to provide a mechanism for exporting on-chain state values from a validator to an external data store. This allows applications to efficiently query their state values. The state delta export implements an event subscription client that subscribes to block commit events and Sawtooth state delta at specific addresses (in this case we will subscribe to all state delta events at the Certificate Registry namespace). Sawtooth sends these events whenever the validator’s state is updated. The events contain the raw state data at the updated addresses. The event subscription client processes the event data and uses it to update the reporting database, an off-chain copy of blockchain state. The REST API can query this database when a client needs to get information from the blockchain.\nThis off-chain state access comes at the expense of relying on a single validator for state updates, this puts the application at risk of having stale data or forked state if the validator supplying the state updates comes out of consensus or is disconnected from the network. Below are guidelines on how to structure the reporting DB so fork resolution is easy.\nReporting Database Structure The reporting DB has three types of tables: sawtooth-core tables (Blocks), domain-specific state tables (Agents, Organizations, Authorizations, Certificates, CertificateData), and application tables (tables supporting off-chain application components, such as Auth, in the schema above). The reporting DB should follow the Type 2 of Slowly Changing Dimensions data management pattern, so that fork resolution is easy.\nFor use in a State Delta Export, a state table includes additional columns of start_block_num and end_block_num. The ​start_block_num​ and ​end_block_num​ columns specify the block range in which that state value is set or exists. Values that are valid as of the current block have ​end_block_num​ set to MAX_UINT_64.\nBecause there might be state objects in the database that refer to the same object in state at different block heights (with different block numbers), the primary key for each object cannot be the same as the object’s natural key in blockchain state. Instead, use a sequence ID column or another unique ID scheme as the primary key. For better query performance, we recommend creating indexes on the natural key of the entry and the end_block_num.\nFork resolution The following pseudocode demonstrates the fork resolution process:\nresolve_fork(existing_block): for table in domain_tables:\tdelete from table where start_block_num \u0026gt;= existing_block.block_num update table set end_block_num = MAX_UINT_64 \\\twhere end_block_num \u0026gt;= existing_block.block_num delete from block where block_num \u0026gt;= existing_block.block_num  ","excerpt":"GitHub Link https://github.com/target/consensource/tree/master/state_delta_subscriber  The goal of …","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/sds/state-delta-subscriber/","title":"State Delta Subscriber"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/terminology/","title":"Terminology"},{"body":" GitHub Link https://github.com/target/consensource/tree/master/processor  ConsenSource is a certificate registry, as data pertaining to the process of factory certification is captured in the ledger state. This Certificate Registry (henceforth referred to as CR) Transaction family displays the interactions currently implemented for any participant that affects state data. Furthermore, this lays out the logic behind all interactions to verify the data submitted to the ledger.\nRelevant Links  Assembling the Future of Smart Contracts with Sawtooth Sabre  Addressing CR data is stored in state using addresses generated from the CR Transaction family name and the object type being stored. In particular, a CR address consists of 4 parts creating a 70 hex character string.\n The first 6 characters of the SHA-256 hash of the UTF-8 encoding of the string \u0026ldquo;certificate_registry\u0026rdquo; (439a56).\n The next 2 characters reserve a namespace and we will start with the namespace 00.\n The next 2 characters are determined by the object type.\n 00 will signify an agent object. 01 will signify a certificate object. 02 will signify an organization object. 03 will signify a standard object. 04 will signify a request object.  The final 60 characters is a truncated value of the SHA-256 hash of the UTF-8 encoding of:\n The public key string of the agent creating the object (first 60 chars of the hash) for an agent object. The certificate id for a certificate object. The organization id for an organization object. The standard id for a standard object. The request id for a request object.   For example, the CR address for the creation of an agent object would look like the following: 439a560000DFB4D55EE01720E8F098CA4F5063C67BDEA82732113C9D41B3F345B1EAFA\nState Agent State A CR Agent state entry is required to consist of the following protobuf message:\nagent.proto\nmessage Agent { // Public key associated with the agent.  string public_key = 1; // A human-readable name identifying the agent.  string name = 2; // A human-readable organization ID identifying the associated org.  string organization_id = 3; // Approximately when the agent was registered.  // Format: UTC timestamp  uint64 timestamp = 4;}message AgentContainer { repeated Agent entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the agent container defined in the proto file above.\nOrganization State A CR Organization state entry is required to consist of the following protobuf message:\norganization.proto\nmessage Organization { enum Type { UNSET_TYPE = 0; CERTIFYING_BODY = 1; STANDARDS_BODY = 2; FACTORY = 3; } message Authorization { enum Role { UNSET_ROLE = 0; ADMIN = 1; TRANSACTOR = 2; } // Public key of the authorized agent. string public_key = 1; // Agent's role within the organization. Role role = 2; } message Contact { // Name of the person. string name = 1; // Contact's phone number. string phone_number = 2; // ISO 639‑1 language code of the contact. string language_code = 3; } // UUID of the organization. string id = 1; // Name of the organization. string name = 2; // List of authorized agents and their roles within the organization. repeated Authorization authorizations = 3; // List contacts within the organization. repeated Contact contacts = 4; // What type of organization this data represents. Type organization_type = 5; // Only one of these fields will be filled based on the organization type. CertifyingBody certifying_body_details = 6; StandardsBody standards_body_details = 7; Factory factory_details = 8; } message CertifyingBody { message Accreditation { // Standard for which the accreditation has been issued. string standard_id = 1; // Standard version for which the accreditation has been issued. string standard_version = 2; // Standards body that issued the accreditation. string accreditor_id = 3; // Time range that the accreditation is valid (UTC Timestamps) uint64 valid_from = 4; uint64 valid_to = 5; } // List of accreditations that the certifying body holds. repeated Accreditation accreditations = 1; } message StandardsBody { // This is message could be used to capture information that is only // pertinent to a StandardsBody } message Factory { message Address { // Street address, Line 1 string street_line_1 = 1; // Street address, Line 2 (optional) string street_line_2 = 2; // City string city = 3; // State or province, (optional) string state_province = 4; // Country string country = 5; // Postal Code, (optional) string postal_code = 6; } // Location of the factory Address address = 1; } message OrganizationContainer { repeated Organization entries = 1; }  In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the organization container defined in the proto file above.\nCertificate State A CR Certificate state entry is required to consist of the following protobuf message:\ncertificate.proto\nmessage Certificate { message CertificateData { // Name of data field associated with certificate data.  string field = 1; // Data stored within the data field.  string data = 2; } // This certificate\u0026#39;s ID.  string id = 1; // Certifying body that issued the certificate.  string certifying_body_id = 2; // Factory the certificate was issued to.  string factory_id = 3; // Standard that this certificate is for.  string standard_id = 4; // Standard version that the certificate is for.  string standard_version = 5; // Additional certificate data.  repeated CertificateData certificate_data = 6; // Time certificate was issued.  // Format: UTC timestamp  uint64 valid_from = 7; // Approximately when the certificate will become invalid.  // Format: UTC timestamp  uint64 valid_to = 8;}message CertificateContainer { repeated Certificate entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the certificate container defined in the proto file above.\nRequest State A CR Request state entry is required to consist of the following protobuf message:\nrequest.proto\nmessage Request { enum Status { UNSET_STATUS = 0; OPEN = 1; IN_PROGRESS = 2; CLOSED = 3; CERTIFIED = 4; } // UUID of this request.  string id = 1; // Status of the request.  Status status = 2; // The standard the factory is requesting certification against.  string standard_id = 3; // UUID of the factory that created this request.  string factory_id = 4; // Time request was made  // Format: UTC timestamp  uint64 request_date = 5;}message RequestContainer { repeated Request entries = 1;} Standard State A CR Standard state entry is required to consist of the following protobuf message:\nrequest.proto\nmessage Standard { message StandardVersion { // Standard version  string version = 1; // Short description of the standard.  string description = 2; // Link to the standard\u0026#39;s documentation.  string link = 3; // Date the standard is officially issued.  uint64 approval_date = 4; } // Sha256 of the standard name  string id = 1; // Id of the organization that created this Standard.  string organization_id = 2; // Name of the standard.  string name = 3; // List of different versions of the standard.  repeated StandardVersion versions = 4;}message StandardContainer { repeated Standard entries = 1;} In the event of a hash collision (i.e. two or more state entries sharing the same address), the colliding state entries will be stored in the request container defined in the proto file above.\nTransaction Payload CR transaction request payloads are defined by the following protobuf structure:\npayload.proto\nmessage CertificateRegistryPayload{ enum Action { UNSET_ACTION = 0; CREATE_AGENT = 1; CREATE_ORGANIZATION = 2; UPDATE_ORGANIZATION = 3; AUTHORIZE_AGENT = 4; ISSUE_CERTIFICATE = 5; CREATE_STANDARD = 6; UPDATE_STANDARD = 7; OPEN_REQUEST_ACTION = 8; CHANGE_REQUEST_STATUS_ACTION = 9; ACCREDIT_CERTIFYING_BODY_ACTION = 10; } // Whether the payload contains a create agent, create organization,  // create certificate, or authorize agent.  Action action = 1; // The transaction handler will read from just one of these fields  // according to the action.  CreateAgentAction create_agent = 2; CreateOrganizationAction create_organization = 3; UpdateOrganizationAction update_organization = 4; AuthorizeAgentAction authorize_agent = 5; IssueCertificateAction issue_certificate = 6; CreateStandardAction create_standard = 7 ; UpdateStandardAction update_standard = 8; OpenRequestAction open_request_action = 9; ChangeRequestStatusAction change_request_status_action = 10; AccreditCertifyingBodyAction accredit_certifying_body_action = 11;} Based on the selected type, the data field will contain the appropriate transaction data (these messages would be defined within the CertificateRegistryPayload):\nCreateAgentAction transaction The CreateAgentAction transaction creates an agent object that is able to sign transactions and perform actions on the behalf of their associated organization. This agent object will be initialized with no associated organization ID.\nCreateAgentAction protobuf\nmessage CreateAgentAction { // A name identifying the agent.  string name = 1; // Approximately when the agent was registered.  // Format: UTC timestamp  uint64 timestamp = 2;} This transaction is considered invalid if one of the following occurs: - Name is not provided - Signing public key already associated with an agent\nCreateOrganizationAction transaction The CreateOrganizationAction transaction creates an organization object. An organization may either be an STANDARDS_BODY, CERTIFYING_BODY or a FACTORY depending on the actions the organization will perform, such as creating standards, issuing or requesting certificates. These actions are performed by authorized agents associated with the organization. The organization object created will be initialized with the agent that signed the transaction as an ADMIN within the organization\u0026rsquo;s authorizations list.\nCreateOrganizationAction protobuf\nmessage CreateOrganizationAction { // UUID of the organization.  string id = 1; // Type of the organization.  Organization.Type organization_type = 2; // Name of the organization.  string name = 3; // Initial contact info for the organization.  repeated Organization.Contact contacts = 4; // Address of the organization (if the organization is a Factory).  Factory.Address address = 5;} This transaction will be considered invalid if one of the following occurs: - Organization ID, name, and/or organization type are not provided - Organization ID already exists - Signing public key is not associated with a valid Agent object - Agent submitting the transaction already has an associated organization - Address is provided if the type is Standards Body or Certifying Body - Address is not provided if the type is Factory\nUpdateOrganizationAction transaction The UpdateOrganizationAction transaction modifies the value of an Organization in state. Both the address (for factories) and the contact information may be updated. The values provided will be applied exactly as submitted with the transaction. If one or the other should stay the same, the original values should be supplied.\nUpdateOrganizationAction protobuf\nmessage UpdateOrganizationAction { // Updated contact info.  repeated Organization.Contact contacts = 1; // Updated address (if Factory).  Factory.Address address = 2;} This transaction is considered invalid if one of the following occurs: - The signer of the transaction is not listed as an admin of their organization - Provided contacts or address objects are not fully filled out - Address is provided if the organization is not a factory\nAuthorizeAgentAction transaction The AuthorizeAgentAction transaction creates an entry within an organization\u0026rsquo;s authorizations list for the specified public key with the specified role. This action may only be performed by an agent authorized as an ADMIN by their associated organization.\nAuthorizeAgentAction protobuf\nmessage AuthorizeAgentAction { // Public key associated with the agent.  string public_key = 1; // Role to update the specified agent entry.  // Roles grant permissions for an agent to act on behalf of the  // organization.  // Whether the agent is an ADMIN or ISSUER.  Organization.Authorization.Role role = 2;} This transaction is considered invalid if one of the following occurs: - Public key is not provided - Role is not provided - Signing public key is not associated an Agent - Public key provided is not associated an Agent - Agent submitting the transaction is not authorized as an ADMIN within their associated organization - Public key provided specifies an Agent already associated with an organization - Invalid authorization role is provided\nIssueCertificateAction transaction The IssueCertificateAction transaction creates a certificate object that contains information pertaining to the specified factory and their adherence to certain policies. A Certificate object is created by an agent associated with a certifying body.\nIssueCertificateAction protobuf\nmessage IssueCertificateAction { enum Source { UNSET_SOURCE = 0; FROM_REQUEST = 1; INDEPENDENT= 2; } // UUID of the certificate.  string id = 1; // ID of the factory that the certificate is being issued to.  string factory_id = 2; // The source that triggered the IssueCertificate Trasaction.  // If set to FROM_REQUEST, it means the IssueCertificateAction is associated  // to a request made by a factory. The field request_id must be set.  // If set to INDEPENDENT, it means the IssueCertificateAction is not associated  // with a request made by a factory. The field factory_id and standard_id must be set.  Source source = 3; // ID of the request (if source is FROM_REQUEST)  string request_id = 4; // Standard that this certificate is for.  string standard_id = 5; // Additional certificate data.  repeated Certificate.CertificateData certificate_data = 6; // Time certificate was issued.  // Format: UTC timestamp  uint64 valid_from = 7; // Approximately when the certificate will become invalid.  // Format: UTC timestamp  uint64 valid_to = 8;} This transaction is considered invalid if one of the following occurs: - ID, factory ID, standard name, valid from timestamp and/or valid to timestamp are not provided - Certificate ID is already associated with a Certificate object - Factory ID does not reference a valid factory - Signing public key is not associated with an agent - Agent submitting the transaction is not associated with a certifying body - Certifying Body associated with the issuing agent is not accredited to issue the standard - Agent submitting the transaction is not an authorized TRANSACTOR within their associated organization - Standard name is not associated with an existing standard - Invalid dates are provided, pertaining to current date as well as format\nCreateStandardAction transaction The CreateStandardAction transaction creates a new certification standard in state. It will also create a StandardVersion sub-object, which contains details specific to the version of the standard which was supplied. A CreateStandardAction transaction is submitted by an agent associated with a standards body.\nCreateStandardAction protobuf\nmessage CreateStandardAction { // Sha256 of the standard name  string standard_id = 1; // Name of the standard.  string name = 2; // Current version of the standard.  string version = 3; // Short description of the standard.  string description = 4; // Link to the standard\u0026#39;s documentation.  string link = 5; // Date the standard is officially issued.  uint64 approval_date = 6;} This transaction is considered invalid if one of the following occurs: - The standard_id, name, version, description, link, or approval date are not provided - The standard_id is already associated with an existing standard - The signer is not associated with a standards body - The signer is not authorized as a transactor within their organization\nUpdateStandardAction transaction The UpdateStandardAction transaction creates a new standard version in state, under the associated standard object. An UpdateStandardAction transaction is submitted by an agent associated with a standards body.\nUpdateStandardAction protobuf\nmessage UpdateStandardAction { // Standard that is being updated.  string standard_id = 1; // New version of the standard.  string version = 2; // Short description of the standard.  string description = 3; // Link to the standard\u0026#39;s documentation.  string link = 4; // Date the standard is officially issued.  uint64 approval_date = 5;} This transaction is considered invalid if one of the following occurs: - The standard_id, version, description, link, or approval date are not provided - The standard_id is not associated with an existing standard - The version is already associated with an existing standard version - The signer is not associated with a standards body - The signer is not authorized as a transactor within their organization - The standard is not associated with the signer\u0026rsquo;s organization\nAccreditCertifyingBodyAction transaction The AccreditCertifyingBodyAction transaction adds an accreditation to a certifying body. An UpdateStandardAction transaction is submitted by an agent associated with a standards body.\nAccreditCertifyingBodyAction protobuf\nmessage AccreditCertifyingBodyAction { // UUID of the certifying body that is being accredited.  string certifying_body_id = 1; // Standard that the certifying body is being accredited for.  string standard_id = 2; // Time the accreditation was issued.  // Format: UTC timestamp  uint64 valid_from = 3; // When the accreditation will become invalid.  // Format: UTC timestamp  uint64 valid_to = 4;} This transaction is considered invalid if one of the following occurs: - The signer is not associated with a standards body - The signer is not authorized as a transactor within their organization - The certifying body ID is not associated with a certifying body - The name is not associated with an existing standard - Invalid dates are provided, pertaining to current date as well as format\nOpenRequestAction transaction The OpenRequestAction transaction opens a request for certification for a factory. This transaction is submitted by an agent associated with a factory and authorized as a TRANSACTOR for their associated factory.\nOpenRequestAction protobuf\nmessage OpenRequestAction { // UUID of the request  string request_id = 1; // Certification standard of which the factory is requesting from an certification body  Request.Certification_Standard certification_standard = 2; // Name of the factory that is opening the request  string factory_name = 3; // Time request was made  // Format: UTC timestamp  uint64 request_date = 4;} This transaction is considered invalid if one of the following occurs: - The signer is not associated with a factory - The signer is not authorized as a transactor within their organization - The id is not unique - The standards name is not associated with a valid standard - If any of these fields are empty\nChangeRequestStatusAction transaction The ChangeRequestStatusAction transaction is performed when a factory\u0026rsquo;s certification request status is changed, such as to CLOSED, IN_PROGRESS, or CERTIFIED. This transaction results from either a factory changing the status to CLOSED or IN_PROGRESS, which would be submitted by an agent associated with the factory and authorized as a TRANSACTOR.\nChangeRequestStatusAction protobuf\nmessage ChangeRequestStatusAction { // Request for which the status is being changed.  string request_id = 1; // New status of the request.  Request.Status status = 2;} This transaction is considered invalid if one of the following occurs: - The signer is not associated with a factory - The signer is not authorized as a transactor within their organization - A request with the provided id does not exist - The status is not a valid status enum: IN_PROGRESS or CLOSED - The status is already CLOSED or CERTIFIED\nTransaction Header Family  family_name: \u0026ldquo;certificate_registry\u0026rdquo; family_version: \u0026ldquo;0.1\u0026rdquo;  Inputs and Outputs The inputs and outputs for Certification Registry transactions will differ depending on the transaction type. Inputs are the address(es) of all the state objects required to validate a transaction. Outputs are the address(es) of all the state objects modified by the transaction.\nCreateAgentAction Transaction Inputs:\n Address of the Agent to be created  Outputs:\n Address of the Agent created  CreateOrganizationAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization to be created\n  Outputs:\n Address of the Agent that submitted the transaction\n Address of the Organization created\n  AuthorizeAgent Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization with the authorization list being modified\n Address of the Agent to be added to the Organization\u0026rsquo;s authorization list\n  Outputs:\n Address of the Organization with a modified authorization list\n Address of the Agent added to the authorization list\n  IssueCertificateAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Organization the certificate is being submitted on behalf of\n Address of the Certificate to be created\n Address of the Standard the certificate is being created against\n  Outputs:\n Address of the Certificate created  CreateStandardAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  Outputs:\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  UpdateStandardAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being created\n Address of the Organization the Standard is being created on behalf of\n  Outputs:\n Address of the Standard that is being created  AccreditCertifyingBodyAction Transaction Inputs:\n Address of the Agent submitting the transaction\n Address of the Standard that is being accredited for\n Address of the Organization that the transaction is being submitted on behalf of\n Address of the Organization that is being accredited\n  Outputs:\n Address of the Organization that is being accredited  OpenRequestAction Transaction Inputs:\n Address of the Request to be created\n Address of the Organization the Request is being made for\n Address of the Standard the Request is being made for\n  Outputs:\n Address of the Request to be created  ChangeRequestStatusAction Transaction Inputs:\n Address of the Request to be updated\n Address of the Organization the Request is being made for\n  Outputs:\n Address of the Request to be updated  Execution The result of a Certificate Registry transaction will differ depending on the type of transaction being executed.\nA successful CreateAgentAction transaction will result in a new Agent object created in state.\nA successful CreateOrganizationAction transaction will result in a new Organization object created in state. This Organization object will be initialized with a single authorization entry corresponding to the Agent that submitted the successful CreateOrganizationAction transaction with a role of ADMIN.\nA successful UpdateOrganizationAction transaction will result in an updated Organization object in state.\nA successful AuthorizeAgentAction transaction will result in a new entry to the specified Organization\u0026rsquo;s authorizations list. The Agent being added to the Authorizations list will also be updated with an associated Organization ID.\nA successful IssueCertificateAction transaction will result in a new Certificate object created in state.\nA successful CreateStandardAction transaction will result in a new Standard object in state, with one StandardVersion sub-object. The Standard will be added to the Standards Body\u0026rsquo;s standards list.\nA successful CreateStandardAction transaction will result in a new Standard object in state, with a new StandardVersion sub-object.\nA successful AccreditCertifyingBodyAction will result in a new Accreditation being added to an Organization object.\nA successful OpenRequestAction transaction will result in a new Request object in state.\nA successful ChangeRequestStatusAction transaction will result in an updated Request object in state with the status of provided. This Request will be submitted on behalf of a Factory.\n.. Licensed under Creative Commons Attribution 4.0 International License .. https://creativecommons.org/licenses/by/4.0/\n","excerpt":"GitHub Link https://github.com/target/consensource/tree/master/processor  ConsenSource is a …","ref":"https://target.github.io/consensource-docs/docs/developer/application-developers-guide/tp/transaction-processor-and-famlies/","title":"Transaction Processor \u0026 Families"},{"body":" This is a placeholder page that shows you how to use this template site.\n If your project has an API, configuration, or other reference - anything that users need to look up that’s at an even lower level than a single task - put (or link to it) here. You can serve and link to generated reference docs created using Doxygen, Javadoc, or other doc generation tools by putting them in your static/ directory. Find out more in Adding static content.\n","excerpt":"This is a placeholder page that shows you how to use this template site.\n If your project has an …","ref":"https://target.github.io/consensource-docs/docs/developer/troubleshooting/","title":"Troubleshooting"},{"body":" These basic sample guidelines assume that your Docsy site is deployed using Netlify and your files are stored in GitHub. You can use the guidelines \u0026ldquo;as is\u0026rdquo; or adapt them with your own instructions: for example, other deployment options, information about your doc project\u0026rsquo;s file structure, project-specific review guidelines, versioning guidelines, or any other information your users might find useful when updating your site. Kubeflow has a great example.\nDon\u0026rsquo;t forget to link to your own doc repo rather than our example site! Also make sure users can find these guidelines from your doc repo README: either add them there and link to them from this page, add them here and link to them from the README, or include them in both locations.\n We use Hugo to format and generate our website, the Docsy theme for styling and site structure, and Netlify to manage the deployment of the site. Hugo is an open-source static site generator that provides us with templates, content organisation in a standard directory structure, and a website generation engine. You write the pages in Markdown (or HTML if you want), and Hugo wraps them up into a website.\nAll submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.\nQuick start with Netlify Here\u0026rsquo;s a quick guide to updating the docs. It assumes you\u0026rsquo;re familiar with the GitHub workflow and you\u0026rsquo;re happy to use the automated preview of your doc updates:\n Fork the Goldydocs repo on GitHub. Make your changes and send a pull request (PR). If you\u0026rsquo;re not yet ready for a review, add \u0026ldquo;WIP\u0026rdquo; to the PR name to indicate it\u0026rsquo;s a work in progress. (Don\u0026rsquo;t add the Hugo property \u0026ldquo;draft = true\u0026rdquo; to the page front matter, because that prevents the auto-deployment of the content preview described in the next point.) Wait for the automated PR workflow to do some checks. When it\u0026rsquo;s ready, you should see a comment like this: deploy/netlify — Deploy preview ready! Click Details to the right of \u0026ldquo;Deploy preview ready\u0026rdquo; to see a preview of your updates. Continue updating your doc and pushing your changes until you\u0026rsquo;re happy with the content. When you\u0026rsquo;re ready for a review, add a comment to the PR, and remove any \u0026ldquo;WIP\u0026rdquo; markers.  Updating a single page If you\u0026rsquo;ve just spotted something you\u0026rsquo;d like to change while using the docs, Docsy has a shortcut for you:\n Click Edit this page in the top right hand corner of the page. If you don\u0026rsquo;t already have an up to date fork of the project repo, you are prompted to get one - click Fork this repository and propose changes or Update your Fork to get an up to date version of the project to edit. The appropriate page in your fork is displayed in edit mode. Follow the rest of the Quick start with Netlify process above to make, preview, and propose your changes.  Previewing your changes locally If you want to run your own local Hugo server to preview your changes as you work:\n Follow the instructions in Getting started to install Hugo and any other tools you need. You\u0026rsquo;ll need at least Hugo version 0.45 (we recommend using the most recent available version), and it must be the extended version, which supports SCSS. Fork the Goldydocs repo repo into your own project, then create a local copy using git clone. Don’t forget to use --recurse-submodules or you won’t pull down some of the code you need to generate a working site.\ngit clone --recurse-submodules --depth 1 https://github.com/google/docsy-example.git  Run hugo server in the site root directory. By default your site will be available at http://localhost:1313/. Now that you\u0026rsquo;re serving your site locally, Hugo will watch for changes to the content and automatically refresh your site.\n Continue with the usual GitHub workflow to edit files, commit them, push the changes up to your fork, and create a pull request.\n  Creating an issue If you\u0026rsquo;ve found a problem in the docs, but you\u0026rsquo;re not sure how to fix it yourself, please create an issue in the Goldydocs repo. You can also create an issue about a specific page by clicking the Create Issue button in the top right hand corner of the page.\nUseful resources  Docsy user guide: All about Docsy, including how it manages navigation, look and feel, and multi-language support. Hugo documentation: Comprehensive reference for Hugo. Github Hello World!: A basic introduction to GitHub concepts and workflow.  ","excerpt":"These basic sample guidelines assume that your Docsy site is deployed using Netlify and your files …","ref":"https://target.github.io/consensource-docs/docs/developer/community/","title":"Community"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/business/","title":"Business Documentation"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/developer/","title":"Developer Documentation"},{"body":" This is a placeholder page. Replace it with your own content.\n Text can be bold, italic, or strikethrough. Links should be blue with no underlines (unless hovered over).\nThere should be whitespace between paragraphs. Vape migas chillwave sriracha poutine try-hard distillery. Tattooed shabby chic small batch, pabst art party heirloom letterpress air plant pop-up. Sustainable chia skateboard art party banjo cardigan normcore affogato vexillologist quinoa meggings man bun master cleanse shoreditch readymade. Yuccie prism four dollar toast tbh cardigan iPhone, tumblr listicle live-edge VHS. Pug lyft normcore hot chicken biodiesel, actually keffiyeh thundercats photo booth pour-over twee fam food truck microdosing banh mi. Vice activated charcoal raclette unicorn live-edge post-ironic. Heirloom vexillologist coloring book, beard deep v letterpress echo park humblebrag tilde.\n90\u0026rsquo;s four loko seitan photo booth gochujang freegan tumeric listicle fam ugh humblebrag. Bespoke leggings gastropub, biodiesel brunch pug fashion axe meh swag art party neutra deep v chia. Enamel pin fanny pack knausgaard tofu, artisan cronut hammock meditation occupy master cleanse chartreuse lumbersexual. Kombucha kogi viral truffaut synth distillery single-origin coffee ugh slow-carb marfa selfies. Pitchfork schlitz semiotics fanny pack, ugh artisan vegan vaporware hexagon. Polaroid fixie post-ironic venmo wolf ramps kale chips.\n There should be no margin above this first sentence.\nBlockquotes should be a lighter gray with a border along the left side in the secondary color.\nThere should be no margin below this final sentence.\n First Header 2 This is a normal paragraph following a header. Knausgaard kale chips snackwave microdosing cronut copper mug swag synth bitters letterpress glossier craft beer. Mumblecore bushwick authentic gochujang vegan chambray meditation jean shorts irony. Viral farm-to-table kale chips, pork belly palo santo distillery activated charcoal aesthetic jianbing air plant woke lomo VHS organic. Tattooed locavore succulents heirloom, small batch sriracha echo park DIY af. Shaman you probably haven\u0026rsquo;t heard of them copper mug, crucifix green juice vape single-origin coffee brunch actually. Mustache etsy vexillologist raclette authentic fam. Tousled beard humblebrag asymmetrical. I love turkey, I love my job, I love my friends, I love Chardonnay!\nDeae legum paulatimque terra, non vos mutata tacet: dic. Vocant docuique me plumas fila quin afuerunt copia haec o neque.\nOn big screens, paragraphs and headings should not take up the full container width, but we want tables, code blocks and similar to take the full width.\nScenester tumeric pickled, authentic crucifix post-ironic fam freegan VHS pork belly 8-bit yuccie PBR\u0026amp;B. I love this life we live in.\nSecond Header 2  This is a blockquote following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\n Header 3 This is a code block following a header.  Next level leggings before they sold out, PBR\u0026amp;B church-key shaman echo park. Kale chips occupy godard whatever pop-up freegan pork belly selfies. Gastropub Belinda subway tile woke post-ironic seitan. Shabby chic man bun semiotics vape, chia messenger bag plaid cardigan.\nHeader 4  This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header.  Header 5  This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header.  Header 6    What Follows     A table A header   A table A header   A table A header    There\u0026rsquo;s a horizontal rule above and below this.\nHere is an unordered list:\n Liverpool F.C. Chelsea F.C. Manchester United F.C.  And an ordered list:\n Michael Brecker Seamus Blake Branford Marsalis  And an unordered task list:\nCreate a Hugo theme Add task lists to it Take a vacation  And a \u0026ldquo;mixed\u0026rdquo; task list:\nPack bags ? Travel!  And a nested list:\n Jackson 5  Michael Tito Jackie Marlon Jermaine  TMNT  Leonardo Michelangelo Donatello Raphael   Definition lists can be used with Markdown syntax. Definition headers are bold.\n Name Godzilla Born 1952 Birthplace Japan Color Green  Tables should have bold headings and alternating shaded rows.\n   Artist Album Year     Michael Jackson Thriller 1982   Prince Purple Rain 1984   Beastie Boys License to Ill 1986    If a table is too wide, it should scroll horizontally.\n   Artist Album Year Label Awards Songs     Michael Jackson Thriller 1982 Epic Records Grammy Award for Album of the Year, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026amp;B Album, Brit Award for Best Selling Album, Grammy Award for Best Engineered Album, Non-Classical Wanna Be Startin\u0026rsquo; Somethin\u0026rsquo;, Baby Be Mine, The Girl Is Mine, Thriller, Beat It, Billie Jean, Human Nature, P.Y.T. (Pretty Young Thing), The Lady in My Life   Prince Purple Rain 1984 Warner Brothers Records Grammy Award for Best Score Soundtrack for Visual Media, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026amp;B Album, Brit Award for Best Soundtrack/Cast Recording, Grammy Award for Best Rock Performance by a Duo or Group with Vocal Let\u0026rsquo;s Go Crazy, Take Me With U, The Beautiful Ones, Computer Blue, Darling Nikki, When Doves Cry, I Would Die 4 U, Baby I\u0026rsquo;m a Star, Purple Rain   Beastie Boys License to Ill 1986 Mercury Records noawardsbutthistablecelliswide Rhymin \u0026amp; Stealin, The New Style, She\u0026rsquo;s Crafty, Posse in Effect, Slow Ride, Girls, (You Gotta) Fight for Your Right, No Sleep Till Brooklyn, Paul Revere, Hold It Now, Hit It, Brass Monkey, Slow and Low, Time to Get Ill    Code snippets like var foo = \u0026quot;bar\u0026quot;; can be shown inline.\nAlso, this should vertically align with this and this.\nCode can also be shown in a block element.\nfoo := \u0026quot;bar\u0026quot;; bar := \u0026quot;foo\u0026quot;;  Code can also use syntax highlighting.\nfunc main() { input := `var foo = \u0026#34;bar\u0026#34;;` lexer := lexers.Get(\u0026#34;javascript\u0026#34;) iterator, _ := lexer.Tokenise(nil, input) style := styles.Get(\u0026#34;github\u0026#34;) formatter := html.New(html.WithLineNumbers()) var buff bytes.Buffer formatter.Format(\u0026amp;buff, style, iterator) fmt.Println(buff.String()) } Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.  Inline code inside table cells should still be distinguishable.\n   Language Code     Javascript var foo = \u0026quot;bar\u0026quot;;   Ruby foo = \u0026quot;bar\u0026quot;{    Small images should be shown at their actual size.\nLarge images should always scale down and fit in the content container.\nThe photo above of the Spruce Picea abies shoot with foliage buds: Bjørn Erik Pedersen, CC-BY-SA.\nComponents Alerts  This is an alert.  Note This is an alert with a title.  Note This is an alert with a title and Markdown.  This is a successful alert.  This is a warning.  Warning This is a warning with a title.  Another Heading ","excerpt":"This is a placeholder page. Replace it with your own content.\n Text can be bold, italic, or …","ref":"https://target.github.io/consensource-docs/docs/developer/parameter-reference/","title":"Parameter Reference"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/index.json","title":""},{"body":"  #td-cover-block-0 { background-image: url(/consensource-docs/about/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_960x540_fill_catmullrom_smart1_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/consensource-docs/about/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_1920x1080_fill_catmullrom_smart1_2.png); } }  About ConsenSource The ConsenSource application leverages Distributed Ledger Technology (DLT) to help retailers, factories, certifying bodies and standards bodies increase transparency and efficiency around the certification process.\nFor many retailers, a commom pain point in the sourcing process is the discovery and verification of the certification claims for a given factory. If a retailer wishes to only do business with factories that have a given environmental certification, where can they find a filtered list of only the factories that are certified? Furthermore, how can they trust that the certification is valid?\nIn practice, each retailer ends up independently verifying these claims with the ceritfying body that performed the original audit. This process is time-consuming, expensive, and error prone.\n       How ConsenSource Can Help \nConsenSource solves this problem of trust and authenticity within the certification process using Distributed Ledger Technology (DLT). The application serves as a common platform to verify and display the certifications and audit data between retailers, factories, certifying bodies, and standards bodies.\nDLT allows all partners to share ownership of this data. Each partner is tasked with the duty of owning their data and keeping this information up to date, shifting the onus of data accuracy to the relevant party. Each participant in the network plays a unique role.\n Standards bodies create standards and accredit certifying bodies.\n Certifying bodies are then able to audit and certify factories against the standards they are accredited for.\n Factories are able to request these certifications and in-person audits, so that certifying bodies are able to issue certificates based on in-person, off-chain audit results.\n Retailers are able to view and trust the resulting data from these interactions as well as general contact and location information on each of these entities.\n      Who Should Use ConsenSource? \n  Retailers     Reduction of overhead associated with tracking and maintaining vendor certification status and factory profile details   Avoidance of negative brand reputation impact by helping achieve and measure towards sustainability goals   Additional visibility to new vendors with applicable certifications and history      Factories     Easy to request certifications resulting in reduction of time locating validated certifying bodies and auditors   Potential for open competition drives audit costs down, or keeps audit costs in check      Certifying Bodies     Potential for increased business due to visibility to any factory interested in certification   Provides a low cost platform for sharing certification status      Standards Bodies     Ability to promote their standards to a wide range of industries, factories, and those requiring standards to further their mission         ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://target.github.io/consensource-docs/about/","title":"About ConsenSource"},{"body":"  #td-cover-block-0 { background-image: url(/consensource-docs/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_960x540_fill_catmullrom_top_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/consensource-docs/featured-background_hu919e1b111d7580bd089eeb6acc112cba_2441262_1920x1080_fill_catmullrom_top_2.png); } }  ConsenSource Read The Docs   View the code   Certification Transparency and Authenticity using Blockchain Technology\n          What is ConsenSource? ConsenSource is an application designed to leverage permissioned Distributed Ledger Technolgy (Blockchain) to bring transparency and trust to the sourcing industry - making it easier to find and verify the certifications and audit histories of a factory.       Trusted The immutable and distributed nature of the blockchain provides verifiable trust that all transactions on the network are authentic.\n   Transparent Certification records and audit history are broadcasted and agreed upon by all members of ConsenSource.\n   Permissioned The ConsenSource governing body controls permissioning of all actors in the network, limiting access to only approved and relevant organizations.\n     How It Works Sorry, your browser doesn't support embedded videos.       ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://target.github.io/consensource-docs/","title":"ConsenSource"},{"body":" What Is A Blockchain? A blockchain is a network in which a record of transactions are maintained across several computers that are linked in a peer-to-peer network. All nodes in this network reach consensus on what the state of the ledger should look like before adding to it. This enforces a level of trust and transparency regarding the authenticity and immutability of data within the ledger.\nBlockchains are a particular type of distributed ledger technology (DLT), and as such, we have elected to use the broader term, DLT, as we further develop ConsenSource.\n What Is A Permissioned Blockchain? Blockchains can be further subdivided into two categories - permissionless and permissioned.\nPermissionless systems, such as Bitcoin and Ethereum, allow anybody to join the network. This approach works great in an open environment such as peer-to-peer cash, but it has two main drawbacks - efficiency and control.\nIn a permsionless system it must be assumed that all actors on the network are potentially malicious. This requires a more costly consensus algorithm, such as Proof-of-Work, in order to verify that transactions are authentic. The second drawback is lack of control over which actors are allowed to join the network. For many enterprise use cases, such as ConsenSource, there is a need to limit the network to only relevant actors.\nPermissioned systems aim to solve these two problems of efficiency and control. ConsenSource uses Hyperledger Sawtooth, an enterprise DLT, to provide an additional layer of security and access control by allowing for on-chain governance.\nIn practice, this means that all members of the network must reach consensus around which new actors are allowed to join the network, the types of actions they can perform, and more. A permissioned DLT lets ConsenSource use a more efficient consensus algorithms (more info here - todo) because there is a base level of trust between participants in the network.\nTakeaway ConsenSource uses a permissioned DLT to provide both greater efficiency, and control, of the network.  Why Use DLT? Benefits  Enhanced Trust  In a centralized database solution, all parties must trust the owner of the database - in situations with potentially untrusted participants, this is often not practical. DLT enforces trust by enabling all parties to share an immutable and complete record of all transactions that occur in the network.  Distributed Responsibility  Rather than a single party bearing the burden of maintaing and running a centralized database, DLT allows multiple parties to collaboratively maintain a ledger of transactions.  Improved Efficiency  The process of manually reconciling multiple ledgers, between multiple parties, is time consuming, expensive, and error prone. By sharing a single digital ledger, all parties recieve more accurate data while performing less work.   Tradeoffs  Blockchain is an emerging technology  As such, the platforms and tools in the blockchain ecosystem are changing rapidly, and many developers have little experience with the technology. The Hyperledger Sawtooth platform supports a wide variety of programming languages for smart contract development, making it easier for new developers to utilize their existing skills.  Reaching consensus is time consuming  The network much reach consensus regarding the validity of all transactions in the network. This takes time, and is slower than a traditional database. ConsenSource utilizes an efficient consensus algorithm to reduce network latency.  Multiple parties need to run validator node  The premise of blockchain technology is built around multiple parties running nodes that validate transactions, rather than a single entity managing and maintaining the network. This enforces transparency and trust around the validity of all transactions. ConsenSource has documentation on running a node in multiple environments.   Why Sawtooth?  ","excerpt":"What Is A Blockchain? A blockchain is a network in which a record of transactions are maintained …","ref":"https://target.github.io/consensource-docs/docs/business/dlt-overview/","title":"Distributed Ledger Technology (DLT) Overview"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/docs/","title":"Documentation"},{"body":"","excerpt":"","ref":"https://target.github.io/consensource-docs/search/","title":"Search Results"}]